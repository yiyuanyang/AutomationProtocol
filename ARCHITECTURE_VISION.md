# AutomationProtocol â€” Architecture Vision

*Distilled from ~6 months of TheResearcher multi-agent build loop*
*Written: 2026-02-20 by Archie, based on Steve's direction*
*See also: [[AutomationProtocol â€” Guardrails Proposal]] (tactical fixes), [[Automation Issues & Hardening]] (issue log)*

---

## The Core Problem

Every major failure in the loop came from the same root cause: **model judgment filling in gaps that should be filled by script logic.**

- Kimi "learned" routing rules from its own prior outputs (no fresh session)
- Codex raised CRs but Claude Code was routed to write a new proposal (routing gap in script)
- Agents hallucinated steps into EXECUTION_PLAN.md (no write protection)
- Agents invented invalid escalation paths (no valid blocker signal in the protocol)
- Advance script crashed on "11b" then on `local` â€” no shellcheck, no smoke test

The fix isn't better prompts. It's a system design where the model can't make these decisions at all.

---

## Principle 1 â€” Script Is Law, Model Executes Tasks

The orchestration script (`review-loop.sh`) owns all routing, state transitions, and control flow. The model's only job is to do the task it was assigned (propose, review, implement, verify).

**What this means in practice:**
- All status/routing logic lives in the script, not in prompt instructions
- All valid state transitions are enumerated in code, not described in prose
- When a new edge case appears, fix the script â€” not the prompt
- A model should never be the one deciding "what happens next"

---

## Principle 2 â€” Fresh Instances, File-Based Context

Every agent invocation gets a blank-slate model. No persistent session. No accumulated conversation history. No "memory" from prior runs.

Context is provided entirely through files read at the start of each run:
- Protocol files (AGENT_CODING_PROTOCOL.md, EXECUTION_PLAN.md)
- State file (.review-loop-state.json)
- Task-specific prompt file (generated by the script for this exact run)
- Review/response files (ENG_REVIEW_COMMENTS.md, ENG_REVIEW_RESPONSE.md)
- Reference index (CODEBASE.md)

**Why:** Persistent sessions accumulate context and start hallucinating. A fresh instance with 5 well-chosen files is more reliable than a 150k-token session with 40 prior turns.

**Implication:** Compaction/summarization scripts run periodically to keep file-based context fresh. Long review archives get compacted. The session isn't the memory â€” the files are.

---

## Principle 3 â€” Branch + PR as the Review Primitive

Replace the current ENG_REVIEW_COMMENTS.md / ENG_REVIEW_RESPONSE.md back-and-forth with native Git workflows.

### Current flow (problematic)
```
Claude Code â†’ writes code + ENG_REVIEW_RESPONSE.md
Codex â†’ reads code + writes ENG_REVIEW_COMMENTS.md
Claude Code â†’ reads comments + writes revised response
... (repeated in flat markdown files with no diff tracking)
```

### Proposed flow
```
Claude Code â†’ creates branch (step-22-settings-page)
            â†’ commits implementation
            â†’ opens PR via `gh pr create`
Codex       â†’ reviews PR via `gh pr review` (line-level comments on actual diffs)
            â†’ approves or requests changes
Claude Code â†’ addresses review comments (new commits to branch)
Script      â†’ detects PR approval â†’ merges â†’ advances step
```

**Benefits:**
- Line-level comments on actual code diffs (not freeform markdown)
- Full diff history per review round
- PR description = proposal; review comments = CRs; approval = merge gate
- Archive is automatic (git history, not manually written review files)
- GitHub CI can run tests on each branch push before review even starts

**Implementation notes:**
- Script wraps `gh pr create`, `gh pr review`, `gh pr merge`
- PR state is the source of truth for phase (open = in review, approved = execute, merged = verified)
- Step flag files still used for cross-run coordination, but review artifacts live in the PR

---

## Principle 4 â€” Review Scope Isolation

A reviewer (Codex) should only see the changes under review. Not the entire codebase history, not 20 rounds of accumulated context, not mandates unrelated to the current diff.

### What this prevents
Codex approved the wrong Step 22 proposal because it was reading:
- The full EXECUTION_PLAN.md (which still had the hallucinated step)
- 15+ rounds of prior review comments
- Accumulated mandate context

The mandate file was updated to say "Step 22 is Settings Page, NOT AI Agent Consultation Tool," but Codex didn't prioritize it against the noise.

### In the PR model
Codex receives:
1. The diff (`git diff main...feature-branch`)
2. The PR description (explicit intent)
3. A filtered mandate list (only mandates touching files in the diff)

That's it. No full-file reads of protocol docs. No historical review rounds. Isolated context = accurate review.

### Implementation
- Review agent invoked with `--diff-only` or limited file set
- PR description includes explicit "What this changes" and "Why"
- Mandates filtered by file path relevance before passing to reviewer
- No access to ENG_REVIEW_COMMENTS.md from prior rounds (those live in the PR history, not in the reviewer's context)

---

## Principle 5 â€” Owner-Protected Files

Some files must never be written by an agent. Violating this has caused two major incidents:
- State file fabrication (Issue 14 â€” fake Step 20 completion)
- EXECUTION_PLAN.md hallucination (Issue 19 â€” fabricated Step 22)

### Protected (owner-only, agent read-only)
- `EXECUTION_PLAN.md` â€” product plan
- `DECISIONS.md` â€” architectural decisions
- `AGENT_CODING_PROTOCOL.md` â€” agent rules
- `scripts/owner-mandates.json` â€” owner directives
- `TECH_DESIGN.md` â€” design doc

### Agent-writable (controlled writes only)
- `ENG_REVIEW_COMMENTS.md` â€” Codex only
- `ENG_REVIEW_RESPONSE.md` â€” Claude Code only
- `.review-loop-state.json` â€” script only (never agents directly)
- `.agent-status.json` â€” agent writes, script consumes

**Enforcement options:**
1. Pre-commit hook: reject commits that modify protected files from non-owner commits
2. Script: validate no protected files are staged before committing agent output
3. CI check: fail if protected files differ from main branch in agent-authored commits

---

## Principle 6 â€” Valid Escalation Path for Blockers

Agents must have a way to signal a real blocker without inventing invalid nextAgent values.

**Add `escalate` as a valid nextAgent:**
```json
{
  "agent": "claude-code",
  "step": "21",
  "status": "blocked",
  "blocker": "ANTHROPIC_API_KEY required â€” cannot run eval script without live API key",
  "nextAgent": "escalate",
  "timestamp": "..."
}
```

**Script behavior when nextAgent=escalate:**
1. Message Steve on Telegram with the blocker description
2. Pause the loop (don't retry the agent)
3. Wait for Steve to either resolve the blocker or inject a new routing flag

This is cleaner than the current "agent writes invalid nextAgent, flag gets rejected, loop stalls silently" failure mode.

---

## Principle 7 â€” Shellcheck + Smoke Test on Script

Every script change must pass:
- `shellcheck review-loop.sh` (catches `local` outside function, unbound vars, quoting bugs)
- `bash scripts/test-loop.sh` (routing coverage, status enum, step name parsing)

The `local` outside function bug was introduced twice. Both would have been caught by shellcheck in under 1 second. Add this to the pre-commit hook.

---

## Principle 8 â€” Instance-Based Task Files

Instead of a single generic prompt file per agent, the script generates a task file for each specific invocation:

```bash
# Script generates task file at trigger time
cat > /tmp/task-step-22-round-1-claude.md << EOF
# Task: Step 22 â€” Propose Settings Page

Step: 22
Round: 1
Phase: propose

Read the following before starting:
- EXECUTION_PLAN.md (Step 22 definition)
- owner-mandates.json (Step 22 mandate)
- CODEBASE.md (file map + relevant lines)
- ENG_REVIEW_COMMENTS.md (no comments yet â€” this is round 1)

Deliverable: Write a proposal in ENG_REVIEW_RESPONSE.md. See AGENT_CODING_PROTOCOL.md for format.

Quality gate: Not applicable for proposal phase.
Flag: Write .agent-status.json with status=proposed, nextAgent=codex when done.
EOF
claude -p "$(cat /tmp/task-step-22-round-1-claude.md)" ...
```

**Why:** The task file makes the agent's assignment explicit, deterministic, and instance-specific. No ambiguity about what round it is, what phase, what files to read. The model has no excuse for drifting or inventing context.

---

## Implementation Priority

| Priority | Change | Effort |
|----------|--------|--------|
| ğŸ”´ Critical | shellcheck in pre-commit | 5 min |
| ğŸ”´ Critical | Protected file enforcement (pre-commit hook) | 30 min |
| ğŸ”´ Critical | `escalate` as valid nextAgent | 1 hr |
| ğŸŸ¡ High | Fresh session per run (cron design) | 1 hr |
| ğŸŸ¡ High | Instance-based task file generation | 2 hr |
| ğŸŸ¡ High | Status enum + routing smoke test | 2 hr |
| ğŸŸ¢ Medium | Branch + PR workflow | 1 day |
| ğŸŸ¢ Medium | Compaction/summarization scripts | 4 hr |

---

*Related: [[AutomationProtocol â€” Guardrails Proposal]], [[Automation Issues & Hardening]]*
